#!/bin/sh
# Name: $RCSfile$
# CVS file: $Source$
# CVS id: $Header$
# Revision: $Revision$
# Revised on: $Date$
# Revised by: $Author$
# Support: Fernando Nunes - fernando.nunes@tmn.pt
# Modified to allow:
# - filtering
# - Parallel execution
# - ids.2000 (long table names)
# Antonio Lima - 2000.11.03
# 
# WARNING: this script opens and uses file descriptor 3.  This has different
# effects on different machines.  Test throughly on each platform.

# This script runs the tbl_updstats script for each table in the database
# orfor tables depending on the selection, i.e
# dbs_updstats stores7 'and tabname like "cust%"
# History:
#
# 1.2 - inclusao de -P para fazer o update statistics as procedures
#     - inclusao de -c e -r para confidence e resolution
# 1.1 - inclusao da opcao -p para establecer o PDQPRIORITY
# 1.0 - insercao no cvs
#     - aplicacao das alteracoes introduzidas pelo Lima


PROGNAME=`basename $0`
VERSAO="1.2"

get_args()
{
	arg_ok='p:d:f:r:c:ePNvh'
	list="$*"
	getopt ${arg_ok} $list >/dev/null 2>&1
	# check result of parsing                                                
	if [ $? != 0 ]
	then
		return 1
	fi
	set -- `getopt "${arg_ok}" $list`

	while [ $1 != -- ]
	do
		case $1 in
		-h)   # show help
		        echo "${PROGNAME}: { -d database } [ -f filter ] [-e] [ -p priority ] [ -P | -N ] [ -r resolution ] [ -c confidence ]" >&1
		        echo "               -d database (obrigatorio)" >&1
		        echo "               -f table filter (opcional)" >&1
		        echo "               [-e] Set explain on (versoes >= a 7.31.UD2 e 9.30.UC2)" >&1
		        echo "               [-p] Set pdqpriority (versoes >= a 7.31.UD2 e 9.30.UC2)" >&1
		        echo "               [-P] efectuar tambem update statistics for procedures (default sem filtro)" >&1
		        echo "               [-N] nao efectuar update statistics for procedures" >&1
                        echo "               [-r] Set resolution" >&2
                        echo "               [-c] Set confidence" >&2
			echo "Ex: dbs_updstats -d stores7 -f \\\" and tabname like \\'l%\\'\\\"" >&1
			exit 0
			;;
		-v)   # show version
			echo "${PROGNAME} versao ${VERSAO}" >&1
			exit 0
			;;
		-e)   # set up the -e (set explain flag)
			EXPLAIN_FLAG=1
			;;
		-d)   # set up the -d (database flag)
			DATABASE_FLAG=1
			dbserver=$2
			shift
			;;
		-p)   # set up the -p (pdqpriority flag)
			PRIORITY_FLAG=1
			priority=$2
			shift
			;;
		-P)   # set up the -P (for procedures flag)
			PROCEDURES_FLAG=1
			;;
		-N)   # set up the -N (NO procedures flag)
			PROCEDURES_FLAG=0
			;;
		-r)   # set up the -r (resolution flag)
			RESOLUTION_FLAG=1
			resolution=$2
			shift
			;;
		-c)   # set up the -c (confidence flag)
			CONFIDENCE_FLAG=1
			confidence=$2
			shift
			;;
		-f)   # set up the -f (filter flag)
			FILTER_FLAG=1
			case $2 in
			\"*)
				sel_filter="`echo $@ | cut -f2 -d'\"' | sed 's/--//'`"
				resto="`echo $* | cut -f3- -d'\"'`"
				;;
			*)
				echo "${PROGNAME}: Erro de sintaxe - Argumento da opcao '-f' tem de ser envolto em aspas" >&2
				return 1
			esac
			if [ "X$resto" = "X" ]
			then
				return
			fi
			arg_ok='p:d:f:r:c:ePNvh'
			set -- `getopt "${arg_ok}" $resto`
			continue
			;;
		esac
		shift
	done
	shift   # skip double dash
	while [ $# -ge 1 ]
	do
		case $1 in
		-e)
			if [ "X"$EXPLAIN_FLAG = "X1" ]	
			then
				echo "${PROGNAME}: Erro de sintaxe - SET EXPLAIN ja foi interpretado" >&2
				return 1
			else
				EXPLAIN_FLAG=1
				shift
			fi;;
		-P)	if [ "X"$PROCEDURES_FLAG = "X1" -o "X"$PROCEDURES_FLAG = "X0" ]
			then
				echo "${PROGNAME}: Erro de sintaxe - as opcoes -P e -N sao exlusivas e nao podem ser repetidas" >&2
				return 1
			else
				PROCEDURES_FLAG=1
				shift
			fi;;
		-N)	if [ "X"$PROCEDURES_FLAG = "X1" -o "X"$PROCEDURES_FLAG = "X0" ]
			then
				echo "${PROGNAME}: Erro de sintaxe - as opcoes -P e -N sao exlusivas e nao podem ser repetidas" >&2
				return 1
			else
				PROCEDURES_FLAG=0
				shift
			fi;;
		-d)
			if [ "X"$DATABASE_FLAG = "X1" ]	
			then
				echo "${PROGNAME}: Erro de sintaxe - DATABASE ja foi interpretado" >&2
				return 1
			elif [ $# -le 1 ]
				then
					echo "${PROGNAME}: Erro de sintaxe - A opcao $1 necessita de um argumento" >&2
					return 1
				else
					DATABASE_FLAG=1
					dbserver=$2
					shift 2
			fi;;
		-p)
			if [ "X"$PRIORITY_FLAG = "X1" ]	
			then
				echo "${PROGNAME}: Erro de sintaxe - PRIORITY ja foi interpretado" >&2
				return 1
			elif [ $# -le 1 ]
				then
					echo "${PROGNAME}: Erro de sintaxe - A opcao $1 necessita de um argumento" >&2
					return 1
				else
					PRIORITY_FLAG=1
					priority=$2
					if [ ${priority} -lt 1 -o ${priority} -gt 100 ]
					then
						echo "${PROGNAME}: Erro - o valor para o PDQPRIORITY tem de estar entre 1 e 100" >&2
						return 1
					fi
					shift 2
			fi;;
		-r)
			if [ "X"$RESOLUTION_FLAG = "X1" ]
			then
				echo "Erro de sintaxe: Resolution ja foi interpretado" >&2
				return 1
			elif [ $# -le 1 ]
				then
					echo "Erro de sintaxe: A opcao $1 necessita de um argumento" >&2
					return 1
				else
					RESOLUTION_FLAG=1
                                        resolution=$2
					echo ${resolution} | grep '^[0-9]\{0,3\}\.\{0,1\}[0-9]\{1,\}$' 2>&1 >/dev/null
					RESULT=$?
                                        if [ ${RESULT} != 0 -o ${resolution} -gt 100 ]
                                        then
                                                echo "Erro: o valor de resolution tem de ser numerico e menor ou igual a 100" >&2
                                                return 1
                                        fi
                                        shift 2
                        fi;;
		-c)
			if [ "X"$CONFIDENCE_FLAG = "X1" ]
			then
				echo "Erro de sintaxe: Confidence ja foi interpretado" >&2
				return 1
			elif [ $# -le 1 ]
				then
					echo "Erro de sintaxe: A opcao $1 necessita de um argumento" >&2
					return 1
				else
					CONFIDENCE_FLAG=1
					confidence=$2
					echo ${confidence} | grep "0\.[89][0-9]*" 2>&1 >/dev/null
					RESULT=$?
					if [ ${RESULT} != 0 ]
					then
						
						echo "Erro: o valor de confidence tem de estar entre 0.80 e 0.99" >&2
						return 1
				fi
				shift 2
			fi;;
		-f)
			if [ "X"$FILTER_FLAG = "X1" ]	
			then
				echo "${PROGNAME}: Erro de sintaxe - FILTER ja foi interpretado" >&2
				return 1
			elif [ $# -le 1 ]
				then
					echo "${PROGNAME}: Erro de sintaxe - A opcao $1 necessita de um argumento" >&2
					return 1
				else
					FILTER_FLAG=1
					case $2 in
					\"*)
						sel_filter="`echo $@ | cut -f2 -d'\"' | sed 's/--//'`"
						resto="`echo $* | cut -f3- -d'\"'`"
						;;
					*)
						echo "${PROGNAME}: Erro de sintaxe - Argumento da opcao! '-f' tem de ser envolto em aspas" >&2
						return 1
					esac
					if [ "X$resto" = "X" ]
					then
						return
					fi
					arg_ok='p:d:f:r:c:ePNvh'
					set -- `getopt "${arg_ok}" $resto`
					continue
			fi;;
		*)
			if [ "X"$DATABASE_FLAG != "X1" ]	
			then
				DATABASE_FLAG=1
				dbserver=$1
				shift
				continue	
			fi
			echo "${PROGNAME}: Erro de sintaxe - "$1 >&2
			return 1;;
		esac
	done
}





get_args $*
if [ $? != 0 ]
then
	echo "Erro no parsing dos parametros" >&2
	exit 1
fi

err=/tmp/dbs_updstats_${dbserver}$$.err

until [ ${dbserver} ]
do
  echo -n "Introduza o nome da base de dados: "
  read dbserver
  if [ -z "${dbserver}" ]
  then
    echo '>> You must enter a database name. <<'
    exit 1
  fi
done

if [ "X${PRIORITY_FLAG}" = "X1" ]
then
	if [ ${priority} -lt 1 -o ${priority} -gt 100 ]
	then
		echo "${PROGNAME}: Erro - o valor para o PRIORITY tem de estar entre 1 e 100" >&2
		exit 1
	fi
fi

if [ "X${RESOLUTION_FLAG}" = "X1" ]
then
	echo ${resolution} | grep '^[0-9]\{0,3\}\.\{0,1\}[0-9]\{1,\}$' 2>&1 >/dev/null
	RESULT=$?
	if [ ${RESULT} != 0 -o ${resolution} -gt 100 ]
	then
		echo "Erro: o valor de resolution tem de ser numerico e menor ou igual a 100" >&2
		exit 1
	else
		resolution_clause=" -r ${resolution} "
	fi
fi

if [ "X${CONFIDENCE_FLAG}" = "X1" ]
then
	echo ${confidence} | grep "0\.[89][0-9]*" 2>&1 >/dev/null
	RESULT=$?
	if [ ${RESULT} != 0 ]
	then
		echo "Erro: O valor da confidence tem de estar entre 0.80 e 0.99" >&2
		exit 1
	else
		confidence_clause=" -c ${confidence} "
	fi
fi

if [ "X"$PROCEDURES_FLAG = "X" ]
then
	if [ "X"$FILTER_FLAG != "X1" ]
	then
		PROCEDURES_FLAG=1
	else
		PROCEDURES_FLAG=0
	fi
fi
# 
result=/tmp/${dbserver}.res
tablelist=/tmp/${dbserver}.tbl
rpt=/tmp/dbs_updstats_${dbserver}$$.rpt

if [ -r ${result} ]
then
	echo "Existe outro ${PROGNAME} a correr ou houve um erro numa execucao anterior" >&2
	echo "Elimine o ficheiro ${result} e tente de novo." >&2
	exit 1
fi

dbaccess ${dbserver} - <<EOC 1>&2 2>${err}
output to pipe "cat  | grep -v '^$' >${result}" without headings
select tabname||":" from systables
where tabid > 99 $sel_filter
order by 1;
EOC

res=$?

if [ ${res} != 0  -o ! -r ${result} ]
then
	echo "${PROGNAME}: Erro ao obter a lista de tabelas:" >&2
	cat < ${err} >&2
	rm -f ${tablelist}
	rm -f ${result}
	rm -f ${err}
	exit 1
fi

linhas=`wc -l ${result} | awk '{print $1}'`

if [ ${linhas} = 0 ]
then
	echo "${PROGNAME}: Nao foram encontradas tabelas que verifiquem o criterio." >&2
	rm -f ${tablelist}
	rm -f ${result}
	rm -f ${err}
	exit 1
fi

grep ':' ${result} | cut -f1 -d:  >${tablelist}

# Start database report
cat /dev/null >$rpt

if [ "X"${EXPLAIN_FLAG} = "X1" ]
then
	CMD_FLAGS="-e"
fi
if [ "X${PRIORITY_FLAG}" = "X1" ]
then
	CMD_FLAGS="${CMD_FLAGS} -p ${priority}"
fi

# Open and use file descriptor 3 to store the list of tables.
exec 3<${tablelist}
while read tblname <&3
do
	echo 'Updating Statistics for Table: '${tblname}
	tbl_updstats -d ${dbserver} -t ${tblname} ${resolution_clause} ${confidence_clause} ${CMD_FLAGS} 2>>${err}&
	T=$!
	wait
	if [ -f /tmp/tbl_updstats_${dbserver}$T.rpt ]
	then
		cat /tmp/tbl_updstats_${dbserver}$T.rpt >>$rpt
		rm /tmp/tbl_updstats_${dbserver}$T.rpt
	fi
	echo '==========================================================================' >>$rpt
	echo ' ' >>$rpt
done

if [ "X"$PROCEDURES_FLAG = "X1" ]
then
	if [ "X"$EXPLAIN_FLAG = "X1" ]
	then
		dbaccess ${dbserver} <<!EOF
		set explain on;
		update statistics for procedure;
!EOF
	else
		dbaccess ${dbserver} <<!EOF
		update statistics for procedure;
!EOF
	fi

	RESULT=$?

	echo "Update statistics for procedure result: " $RESULT >>$rpt
	echo '==========================================================================' >>$rpt
fi

rm -f ${tablelist}
rm -f ${result}
rm -f ${err}
 
exit 0

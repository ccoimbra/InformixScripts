#!/bin/sh
# Name: $RCSfile$
# CVS file: $Source$
# CVS id: $Header$
# Revision: $Revision$
# Revised on: $Date$
# Revised by: $Author$
# Support: Fernando Nunes - fernando.nunes@tmn.pt
# Notes:
# WARNING: This script opens and uses file descriptor 4.  Test throughly on
# each platform.
# Script to create the 'update statisics' statements as discribed in the
# Guide to 7.1 Feature Enhancements Page 3-133
# This script assumes all environment variables are set.
# History:
# 1.2 - Adicao de -r e -c para resolution e confidence
#     - Adicao de -D para display apenas
# 1.1 - Adicao da flag para establecer pdqpriority
#     - alteracao no high para especificar as varias colunas num so statement


#-------------------------------------------------------
# parameter processing
#-------------------------------------------------------

PROGNAME=`basename $0`
VERSAO="1.2"
DEFAULT_RESOLUTION=2.5

get_args()
{
	arg_ok="d:t:p:r:c:hevD"
	list="$*"
	getopt ${arg_ok} $list >/dev/null 2>&1
	# check result of parsing                                                
	if [ $? != 0 ]
	then
		return 1
	fi
	set -- `getopt "${arg_ok}" $list`

	while [ $1 != -- ]
	do
		case $1 in
		-h)   # show help
		        echo "${PROGNAME}: { [-d] database } { [-t] table }[-e] [ -p priority ] [ -r resolution ] [ -c confidence ]" >&2
		        echo "               [-d] database (obrigatorio)" >&2
		        echo "               [-t] table (obrigatorio)" >&2
		        echo "               [-p] Set PDQPRIORITY (versoes >= a 7.31.UD2 e 9.30.UC2)" >&2
			echo "               [-r] Set resolution" >&2
			echo "               [-c] Set confidence" >&2
		        echo "               [-e] Set explain on (versoes >= a 7.31.UD2 e 9.30.UC2)" >&2
			echo "               [-D] Display only. Don't execute" >&2
			exit 0
			;;
		-v)   # show version
			echo "${PROGNAME} versao ${VERSAO}"
			exit 0
			;;
		-e)   # set up the -e (set explain flag)
			EXPLAIN_FLAG=1
			;;
		-D)   # set up the -D (set DISPLAY_ONLY flag)
			DISPLAY_FLAG=1
			;;
		-d)   # set up the -d (database flag)
			DATABASE_FLAG=1
			dbserver=$2
			shift
			;;
		-t)   # set up the -f (filter flag)
			TABLE_FLAG=1
			tabname=$2
			shift
			;;
		-p)   # set up the -p ( PDQPRIORITY flag)
			PRIORITY_FLAG=1
			priority=$2
			shift
			;;
		-r)   # set up the -r (resolution flag)
			RESOLUTION_FLAG=1
			resolution=$2
			shift
			;;
		-c)   # set up the -c (confidence flag)
			CONFIDENCE_FLAG=1
			confidence=$2
			shift
			;;
		esac
		shift
	done
	shift   # skip double dash
	while [ $# -ge 1 ]
	do
		case $1 in
		-D)
			if [ "X"$DISPLAY_FLAG = "X1" ]	
			then
				echo "${PROGNAME}: Erro de sintaxe - DISPLAY ja foi interpretado" >&2
				return 1
			else
				DISPLAY_FLAG=1
				shift
			fi;;
		-e)
			if [ "X"$EXPLAIN_FLAG = "X1" ]	
			then
				echo "${PROGNAME}: Erro de sintaxe - SET EXPLAIN ja foi interpretado" >&2
				return 1
			else
				EXPLAIN_FLAG=1
				shift
			fi;;
		-h)   # show help
		        echo "${PROGNAME}: [-e] { [-d] database } { [-t] table }" >&2
		        echo "               [-e] Set explain on (versoes >= a 7.31.UD2 e 9.30.UC2)" >&2
		        echo "               [-d] database (obrigatorio)" >&2
		        echo "               [-t] table (obrigatorio)" >&2
			exit 0
			;;
		-v)   # show version
			echo "${PROGNAME} versao ${VERSION}"
			exit 0
			;;
		-d)
			if [ "X"$DATABASE_FLAG = "X1" ]	
			then
				echo "Erro de sintaxe: DATABASE ja foi interpretado" >&2
				return 1
			elif [ $# -le 1 ]
				then
					echo "Erro de sintaxe: A opcao $1 necessita de um argumento" >&2
					return 1
				else
					DATABASE_FLAG=1
					dbserver=$2
					shift 2
			fi;;
		-t)
			if [ "X"$TABLE_FLAG = "X1" ]	
			then
				echo "Erro de sintaxe: TABLE ja foi interpretado" >&2
				return 1
			elif [ $# -le 1 ]
				then
					echo "Erro de sintaxe: A opcao $1 necessita de um argumento" >&2
					return 1
				else
					TABLE_FLAG=1
					tabname=$2
					shift 2
			fi;;
		-p)
			if [ "X"$PRIORITY_FLAG = "X1" ]	
			then
				echo "Erro de sintaxe: PRIORITY ja foi interpretado" >&2
				return 1
			elif [ $# -le 1 ]
				then
					echo "Erro de sintaxe: A opcao $1 necessita de um argumento" >&2
					return 1
				else
					PRIORITY_FLAG=1
					priority=$2
					if [ ${priority} -lt 1 -o ${priority} -gt 100 ]
					then
						echo "Erro: o valor de PDQPRIORITY tem de estar entre 0 e 100" >&2
						return 1
					fi
					shift 2
			fi;;
		-r)
			if [ "X"$RESOLUTION_FLAG = "X1" ]
			then
				echo "Erro de sintaxe: Resolution ja foi interpretado" >&2
				return 1
			elif [ $# -le 1 ]
				then
					echo "Erro de sintaxe: A opcao $1 necessita de um argumento" >&2
					return 1
				else
					RESOLUTION_FLAG=1
                                        resolution=$2
					echo ${resolution} | grep '^[0-9]\{0,3\}\.\{0,1\}[0-9]\{1,\}$' 2>&1 >/dev/null
					RESULT=$?
                                        if [ ${RESULT} != 0 -o ${resolution} -gt 100 ]
                                        then
                                                echo "Erro: o valor de resolution tem de ser numerico e menor ou igual a 100" >&2
                                                return 1
                                        fi
                                        shift 2
                        fi;;
		-c)
			if [ "X"$CONFIDENCE_FLAG = "X1" ]
			then
				echo "Erro de sintaxe: Confidence ja foi interpretado" >&2
				return 1
			elif [ $# -le 1 ]
				then
					echo "Erro de sintaxe: A opcao $1 necessita de um argumento" >&2
					return 1
				else
					CONFIDENCE_FLAG=1
					confidence=$2
					echo ${confidence} | grep "0\.[89][0-9]*" 2>&1 >/dev/null
					RESULT=$?
					if [ ${RESULT} != 0 ]
					then
						
						echo "Erro: o valor de confidence tem de estar entre 0.80 e 0.99" >&2
						return 1
				fi
				shift 2
			fi;;
		*)
			if [ "X"$DATABASE_FLAG != "X1" ]	
			then
				DATABASE_FLAG=1
				dbserver=$1
				shift
				continue	
			fi
			if [ "X"$TABLE_FLAG != "X1" ]	
			then
				TABLE_FLAG=1
				tabname=$1
				shift
				continue	
			fi
			echo "${PROGNAME}: Erro de sintaxe: "$1 >&2
			return 1;;
		esac
	done
}





get_args $*
if [ $? != 0 ]
then
	echo "Erro no parsing dos parametros" >&2
	exit 1
fi

until [ ${dbserver} ]
do
  echo -n "Introduza o nome da base de dados: "
  read dbserver
done
 
until [ ${tabname} ]
do
  echo -n "Introduza o nome da tabela: "
  read tabname
done
 
# lower case table name
tabname2=`echo ${tabname} | tr "[A-Z]" "[a-z]"`
tabname=${tabname2}
if [ "X${PRIORITY_FLAG}" = "X1" ]
then
	if [ 1 -gt ${priority}  -o  ${priority} -gt 100 ]
	then
		echo "Erro: o valor de PDQPRIORITY tem de estar entre 0 e 100" >&2
		exit 1
	fi
fi

if [ "X${RESOLUTION_FLAG}" = "X1" ]
then
	echo ${resolution} | grep '^[0-9]\{0,3\}\.\{0,1\}[0-9]\{1,\}$' 2>&1 >/dev/null
	RESULT=$?
	if [ ${RESULT} != 0 -o ${resolution} -gt 100 ]
	then
		echo "Erro: o valor de resolution tem de ser numerico e menor ou igual a 100" >&2
		exit 1
	fi
fi
 
if [ "X${CONFIDENCE_FLAG}" = "X1" ]
then
	echo ${confidence} | grep "0\.[89][0-9]*" 2>&1 >/dev/null
	RESULT=$?
	if [ ${RESULT} != 0 ]
	then
		echo "Erro: O valor da confidence tem de estar entre 0.80 e 0.99" >&2
		exit 1
	fi
fi
# define filenames using process id
sqlfile=/tmp/tbl_updstats$$.sql
result=/tmp/tbl_updstats$$.r0
 

#--------------------------------------------------------
# find the index header columns
#--------------------------------------------------------
cat /dev/null >${result}
echo "output to ${result} without headings
      select tabname||':'||idxname||':'||colname
      from systables t, sysindexes i, syscolumns c
      where tabname = '${tabname}' 
      and t.tabid = i.tabid
      and t.tabid = c.tabid
      and colno = part1 
      order by 1;" >${sqlfile}

dbaccess ${dbserver} ${sqlfile}
result1=/tmp/tbl_updstats$$.r1
grep "\:" ${result} >${result1}
 
#--------------------------------------------------------
# find the index non-header columns
#--------------------------------------------------------
echo "
 output to ${result} without headings
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part2 is not null and colno = part2 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part3 is not null and colno = part3 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part4 is not null and colno = part4 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part5 is not null and colno = part5 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part6 is not null and colno = part6 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part7 is not null and colno = part7 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part8 is not null and colno = part8 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part9 is not null and colno = part9 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part10 is not null and colno = part10 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part11 is not null and colno = part11 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part12 is not null and colno = part12 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part13 is not null and colno = part13 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part14 is not null and colno = part14 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part15 is not null and colno = part15 
  union
 select tabname||':'||idxname||':'||colname
 from systables t, sysindexes i, syscolumns c
 where tabname = '${tabname}' 
 and t.tabid = i.tabid and t.tabid = c.tabid
 and part16 is not null and colno = part16 
 ;" >${sqlfile}

dbaccess ${dbserver} ${sqlfile}
result2=/tmp/tbl_updstats$$.r2
grep "\:" ${result} >${result2}
x=/tmp/tbl_updstats$$.x
cp ${result} $x
 
#-------------------------------------------------------
# Report of indexes
#-------------------------------------------------------
rpt=/tmp/tbl_updstats$$.rpt

cat /dev/null >${rpt}
echo TABLE: ${tabname} >>${rpt}
date >>${rpt}

lines=`wc -l ${result1} | awk '{print $1}'`
if [ ${lines} -ge 1 ]
then
	echo '
Table Name        :Index Name        :Column Name
------------------:------------------:-----------------------' >>${rpt}
	echo '<< Columns heading an index. >> ' >>${rpt}
	cat ${result1} >>${rpt}
fi
lines=`wc -l ${result2} | awk '{print $1}'`
if [ ${lines} -ge 1 ]
then
	echo '<< Columns NOT heading an index. >> ' >>${rpt}
	cat ${result2} >>${rpt}
fi
echo >>${rpt}
 
#-------------------------------------------------------
# Create sql statements for medium distributions 
#-------------------------------------------------------
ms=/tmp/tbl_updstats$$_ms.sql
echo > ${ms}

if [ "X"${EXPLAIN_FLAG} = "X1" ]
then
	echo "set explain on;" >>${ms}
fi
if [ "X"${PRIORITY_FLAG} = "X1" ]
then
	echo "set pdqpriority ${priority};" >>${ms}
fi
if [ "X${RESOLUTION_FLAG}" = "X1" -o "X${CONFIDENCE_FLAG}" = "X1" ]
then
	if [ "X${RESOLUTION_FLAG}" != "X1" ]
	then
		resolution_clause_medium=" resolution ${DEFAULT_RESOLUTION} ${confidence} "
	else
		resolution_clause_medium=" resolution ${resolution} ${confidence} "
		resolution_clause_high=" resolution ${resolution} "
	fi
fi
echo "update statistics medium for table ${tabname} ${resolution_clause_medium} distributions only;" >>${ms}
 
#-------------------------------------------------------
# Create sql statements for high distributions
#-------------------------------------------------------
col_high=/tmp/tbl_updstats$$_colh.sql
cut -f3 -d: ${result1} | sort | uniq  >${col_high}

#-------------------------------------------------------
# Open and use fd 4 to store the list of columnns
#-------------------------------------------------------
exec 4<${col_high}
primeiro=1
while read colname <&4
do
if [ $primeiro -eq 1 ]
then
	echo "update statistics high for table ${tabname} (" >>${ms}
	primeiro=0
else
	echo ',' >>${ms}
fi
echo ${colname} >>${ms}
done
if [ $primeiro != 1 ]
then
	echo ")  ${resolution_clause_high} distributions only;" >>${ms}
fi
 
#-------------------------------------------------------
# Create sql statements for low 
#-------------------------------------------------------
col_low=/tmp/tbl_updstats$$_coll.sql
cut -f3 -d: ${result2} | sort | uniq  >${result}
comm -13 ${col_high} ${result} >${col_low}
echo 'update statistics low for table '${tabname}';' >>${ms}

#-------------------------------------------------------
# Execute SQL instrctions
#-------------------------------------------------------
if [ "X${DISPLAY_FLAG}" = "X1" ]
then
	cat ${ms}
else
	dbaccess ${dbserver} - <${ms} 1>/dev/null #2>&1 
	cat ${ms} >>${rpt}
fi
 
mv  ${rpt} /tmp/tbl_updstats_${dbserver}$$.rpt
rm  -f ${ms} ${x} ${sqlfile} ${result} ${result1} ${result2} ${col_high} ${col_low}
 
exit 0

